## 接口
接口是对对象行为的抽象和概括，**Go** 语言的接口类型是延迟绑定，接口只负责定义对象应该做什么，具体实现由对象本身确定。当一个类型定义了接口中的所有方法，我们认为它实现了该接口。

## 接口的定义
```go
type interfaceName interface {
    method()
}
```

## 接口的实现
```go
package main

import "fmt"

// 定义 Animal 接口
type Animal interface {
    Eat()
    Play()
}

// 定义 Dog 结构体
type Dog struct {
    name string
}

// 实现 Eat 方法
func (dog Dog) Eat() {
    fmt.Printf("%s is eating bone.\n", dog.name)
}

// 实现 Play 方法
func (dog Dog) Play() {
    fmt.Printf("%s is palying ball.\n", dog.name)
}

// 测试
func main() {
    dog := Dog{name: "Tom"}
    var tom Animal = &dog
    tom.Eat()
    tom.Play()
}
```

首先我们定义了 **Animal** 接口，其中有两个方法 **Eat** 和 **Play**，接着我们定义了 **Dog** 结构体且实现了 **Animal** 的两个方法。当我们注释掉其中一个方法的实现的时候，代码编译会报错。
```go
// 我们将Play方法注释掉
//func (dog *Dog) Play() {
//    fmt.Printf("%s is palying ball.", dog.name)
//}

// 该行编译报错
var tom Animal = &dog
```
编译错误信息如下
```go
cannot use '&dog' (type *Dog) as type Animal in assignment
Type does not implement 'Animal' as some methods are missing: Play()
```

## 接口的多态
上面的示例，我们定义了结构体 **Dog** 实现了接口，我们可以再定义一个结构体 **Cat** 来实现接口，然后定义了 **eat** 方法，可以传入类型为 **Animal** 的参数
```go
package main

import "fmt"

// 定义 Animal 接口
type Animal interface {
    Eat()
    Play()
}

// 定义 Dog 结构体
type Dog struct {
    name string
}

// 实现 Eat 方法
func (dog Dog) Eat() {
    fmt.Printf("%s is eating bone.\n", dog.name)
}

// 实现 Play 方法
func (dog Dog) Play() {
   fmt.Printf("%s is palying ball.\n", dog.name)
}

// 定义 Cat 结构体
type Cat struct {
    name string
}

// 实现 Eat 方法
func (cat Cat) Eat() {
    fmt.Printf("%s is eating a mouse.\n", cat.name)
}

// 实现 Play 方法
func (cat Cat) Play() {
    fmt.Printf("%s is palying a mouse.\n", cat.name)
}

// 定义函数，入参类型是 **Animal**
func eat(animal Animal) {
    animal.Eat()
}

// 测试
func main() {
    dog := Dog{name: "Tom"}
    cat := Cat{name: "Jerry"}
    eat(dog)
    eat(cat)
}
```
